{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/PAVILION/Downloads/Proyecto_2/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst express = require('express');\n\nconst mongoose = require('mongoose');\n\nconst bcrypt = require('bcrypt');\n\nconst cors = require('cors');\n\nconst jwt = require('jsonwebtoken'); // Crear la instancia de la aplicación Express\n\n\nconst app = express();\nconst claveSecreta = 'tu_clave_secreta'; // Conectar a la base de datos de MongoDB\n\nmongoose.connect('mongodb+srv://dsolorzanom1:Devin01@usuarios.ijnb0li.mongodb.net/Almacenar_usuarios?retryWrites=true&w=majority', {\n  useNewUrlParser: true,\n  useUnifiedTopology: true\n}).then(() => {\n  console.log('Conexión exitosa a la base de datos');\n}).catch(error => {\n  console.error('Error al conectar a la base de datos', error);\n}); // Definir el esquema del usuario\n\nconst userSchema = new mongoose.Schema({\n  nombre: String,\n  email: String,\n  password: String\n}); // Crear el modelo de usuario\n\nconst User = mongoose.model('User', userSchema); // Middleware para procesar datos en formato JSON\n\napp.use(express.json());\napp.use(cors()); // Ruta para el registro de usuarios\n\napp.post('/registro', /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (req, res) {\n    try {\n      const {\n        nombre,\n        email,\n        password\n      } = req.body; // Verificar si el usuario ya existe en la base de datos\n\n      const existingUser = yield User.findOne({\n        email\n      });\n\n      if (existingUser) {\n        return res.status(400).json({\n          message: 'El email ya está registrado'\n        });\n      } // Generar el hash de la contraseña\n\n\n      const salt = yield bcrypt.genSalt(10);\n      const hashedPassword = yield bcrypt.hash(password, salt); // Crear un nuevo usuario en la base de datos\n\n      const newUser = new User({\n        nombre,\n        email,\n        password: hashedPassword\n      });\n      yield newUser.save();\n      res.status(201).json({\n        message: 'Usuario registrado correctamente'\n      });\n    } catch (error) {\n      console.error('Error en el registro de usuario', error);\n      res.status(500).json({\n        message: 'Error en el servidor'\n      });\n    }\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}()); // Ruta para el inicio de sesión de usuarios\n\napp.post('/ingreso', /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (req, res) {\n    try {\n      const {\n        email,\n        password\n      } = req.body; // Buscar al usuario en la base de datos por su email\n\n      const user = yield User.findOne({\n        email\n      });\n\n      if (!user) {\n        return res.status(401).json({\n          message: 'Email o contraseña incorrectos'\n        });\n      } // Verificar la contraseña\n\n\n      const isPasswordValid = yield bcrypt.compare(password, user.password);\n\n      if (!isPasswordValid) {\n        return res.status(401).json({\n          message: 'Email o contraseña incorrectos'\n        });\n      } // Generar el token de autenticación\n\n\n      const token = jwt.sign({\n        email: user.email\n      }, claveSecreta); // Autenticación exitosa\n\n      res.json({\n        message: 'Inicio de sesión exitoso',\n        token\n      });\n    } catch (error) {\n      console.error('Error en el inicio de sesión', error);\n      res.status(500).json({\n        message: 'Error en el servidor'\n      });\n    }\n  });\n\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}());\n\nfunction validarToken(req, res, next) {\n  // Obtener el token de la cabecera de autorización\n  const token = req.headers.authorization; // Verificar si el token existe\n\n  if (!token) {\n    return res.status(401).json({\n      message: 'Acceso no autorizado'\n    });\n  }\n\n  try {\n    // Verificar y decodificar el token\n    const decodedToken = jwt.verify(token, claveSecreta); // Agregar el usuario decodificado al objeto de solicitud para usarlo en las rutas protegidas\n\n    req.usuario = decodedToken; // Continuar con la siguiente función de middleware\n\n    next();\n  } catch (error) {\n    return res.status(401).json({\n      message: 'Acceso no autorizado'\n    });\n  }\n} // Ruta protegida que requiere autenticación\n\n\napp.get('/perfil', validarToken, (req, res) => {\n  // El usuario está autenticado y se puede acceder a la ruta protegida\n  res.json({\n    message: 'Acceso autorizado a la ruta protegida'\n  });\n}); // Iniciar el servidor\n\napp.listen(3000, () => {\n  console.log('Servidor iniciado en el puerto 3000');\n});","map":{"version":3,"mappings":"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","names":["express","require","mongoose","bcrypt","cors","jwt","app","claveSecreta","connect","useNewUrlParser","useUnifiedTopology","then","console","log","catch","error","userSchema","Schema","nombre","String","email","password","User","model","use","json","post","req","res","body","existingUser","findOne","status","message","salt","genSalt","hashedPassword","hash","newUser","save","user","isPasswordValid","compare","token","sign","validarToken","next","headers","authorization","decodedToken","verify","usuario","get","listen"],"sourceRoot":"","sources":["C:\\Users\\PAVILION\\Downloads\\Proyecto_2\\frontend\\src\\app\\app-routing.module.ts"],"sourcesContent":["const express = require('express');\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcrypt');\nconst cors = require('cors');\nconst jwt = require('jsonwebtoken');\n\n// Crear la instancia de la aplicación Express\nconst app = express();\n\nconst claveSecreta = 'tu_clave_secreta';\n\n// Conectar a la base de datos de MongoDB\nmongoose\n  .connect('mongodb+srv://dsolorzanom1:Devin01@usuarios.ijnb0li.mongodb.net/Almacenar_usuarios?retryWrites=true&w=majority', {\n    useNewUrlParser: true,\n    useUnifiedTopology: true,\n  })\n  .then(() => {\n    console.log('Conexión exitosa a la base de datos');\n  })\n  .catch((error: any) => {\n    console.error('Error al conectar a la base de datos', error);\n  });\n\n// Definir el esquema del usuario\nconst userSchema = new mongoose.Schema({\n  nombre: String,\n  email: String,\n  password: String,\n});\n\n// Crear el modelo de usuario\nconst User = mongoose.model('User', userSchema);\n\n// Middleware para procesar datos en formato JSON\napp.use(express.json());\napp.use(cors());\n\n// Ruta para el registro de usuarios\napp.post('/registro', async (req: any, res: any) => {\n  try {\n    const { nombre, email, password } = req.body;\n\n    // Verificar si el usuario ya existe en la base de datos\n    const existingUser = await User.findOne({ email });\n    if (existingUser) {\n      return res.status(400).json({ message: 'El email ya está registrado' });\n    }\n\n    // Generar el hash de la contraseña\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(password, salt);\n\n    // Crear un nuevo usuario en la base de datos\n    const newUser = new User({\n      nombre,\n      email,\n      password: hashedPassword,\n    });\n    await newUser.save();\n\n    res.status(201).json({ message: 'Usuario registrado correctamente' });\n  } catch (error: any) {\n    console.error('Error en el registro de usuario', error);\n    res.status(500).json({ message: 'Error en el servidor' });\n  }\n});\n\n// Ruta para el inicio de sesión de usuarios\napp.post('/ingreso', async (req: any, res: any) => {\n  try {\n    const { email, password } = req.body;\n\n    // Buscar al usuario en la base de datos por su email\n    const user = await User.findOne({ email });\n    if (!user) {\n      return res.status(401).json({ message: 'Email o contraseña incorrectos' });\n    }\n\n    // Verificar la contraseña\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    if (!isPasswordValid) {\n      return res.status(401).json({ message: 'Email o contraseña incorrectos' });\n    }\n\n    // Generar el token de autenticación\n    const token = jwt.sign({ email: user.email }, claveSecreta);\n\n    // Autenticación exitosa\n    res.json({ message: 'Inicio de sesión exitoso', token });\n  } catch (error: any) {\n    console.error('Error en el inicio de sesión', error);\n    res.status(500).json({ message: 'Error en el servidor' });\n  }\n});\n\nfunction validarToken(req: any, res: any, next:any) {\n  // Obtener el token de la cabecera de autorización\n  const token = req.headers.authorization;\n\n  // Verificar si el token existe\n  if (!token) {\n    return res.status(401).json({ message: 'Acceso no autorizado' });\n  }\n\n  try {\n    // Verificar y decodificar el token\n    const decodedToken = jwt.verify(token, claveSecreta);\n\n    // Agregar el usuario decodificado al objeto de solicitud para usarlo en las rutas protegidas\n    req.usuario = decodedToken;\n\n    // Continuar con la siguiente función de middleware\n    next();\n  } catch (error) {\n    return res.status(401).json({ message: 'Acceso no autorizado' });\n  }\n}\n\n// Ruta protegida que requiere autenticación\napp.get('/perfil', validarToken, (req: any, res: any) => {\n  // El usuario está autenticado y se puede acceder a la ruta protegida\n  res.json({ message: 'Acceso autorizado a la ruta protegida' });\n});\n\n// Iniciar el servidor\napp.listen(3000, () => {\n  console.log('Servidor iniciado en el puerto 3000');\n});\n"]},"metadata":{},"sourceType":"script"}